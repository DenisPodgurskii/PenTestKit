/* Author: Denis Podgurskii */
import { ptk_decoder } from "../background/decoder.js"
import { ptk_ruleManager, ptk_utils } from "../background/utils.js"
import { jsonLogic } from '../packages/json-logic-js/logic.js'

export class ptk_module {
    constructor(module) {
        Object.assign(this, module)
        this.decoder = new ptk_decoder()
        this.nonAttackParams = ['csrf', '_csrf']

        jsonLogic.add_operation("regex", this.validateRegex)
    }

    validateRegex(obj, pattern) {
        let success = false
        let proof = ""
        pattern = new RegExp(pattern, "gmi")
        if (Array.isArray(obj)) {
            Object.entries(obj).forEach(([_key, _value]) => {
                if (pattern.test(JSON.stringify(_value))) {
                    success = true
                    proof = JSON.stringify(_value).match(pattern)[0]
                }
            })
        } else {
            success = pattern.test(obj)
            if (success)
                proof = obj.match(pattern)[0]//pattern.exec(obj)[0]
        }
        return { success, proof }
    }

    modifyParam(name, param, options) {
        if (this.nonAttackParams.includes(name)) return param
        if (options.regex) {
            let r = new RegExp(options.regex)
            param = param.replace(r, options.attackValue)
        } else if (options.position == 'before') {
            param = options.attackValue + param
        } else if (options.position == 'after') {
            param = param + options.attackValue
        } else if (options.position == 'replace') {
            param = options.attackValue
        }

        return param
    }

    modifyPostParams(schema, options) {
        let params = schema.request.body?.params
        if (params) {
            for (let i in params) {
                params[i].value = this.modifyParam(params[i].name, params[i].value, options)
            }
            schema.request.bodySize = (new URLSearchParams(schema.request.body.params.map(x => `${x.name}=${x.value}`).join('&'))).toString().length
            if (schema.request.headers.find(x => x.name == 'Content-Length'))
                schema.request.headers.find(x => x.name == 'Content-Length').value = (new URLSearchParams(schema.request.body.params.map(x => `${x.name}=${x.value}`).join('&'))).toString().length.toString()
        }
        return schema
    }

    modifyGetParams(schema, options) {
        let url = new URL(schema.request.target)
        for (const [key, value] of url.searchParams) {
            let v = this.modifyParam(key, value, options)
            url.searchParams.set(key, v)
        }
        //url.searchParams.set('ptk_unique', ptk_utils.attackParamId())
        schema.request.target = url.toString()
        return schema
    }

    modifyHeaders(schema, options) {
        let params = schema.request.headers
        for (let i in params) {
            params[i].value = this.modifyParam(params[i].name, params[i].value, options)
        }
        return schema
    }

    validateAttackConditions(schema, conditions, original, preattack) {
        let _return = true
        if (conditions) {
            _return = jsonLogic.apply(conditions, { "original": original, "module": this, "preattack": preattack })
        }

        if (typeof (_return) == 'object') {
            return _return.success
        }
        return _return
    }

    prepareAttack(attack, random) {
        let _attack = JSON.parse(JSON.stringify(attack))
        if (_attack.options?.random) {
            _attack.options.attackValue = _attack.options.attackValue.replace(_attack.options.random, random)
            _attack.validation.regex = JSON.parse(JSON.stringify(_attack.validation.regex).replace(_attack.options.random, random))
            if (_attack.options.attackParamValue === null) _attack.options.attackParamValue = random
        }
        if (!_attack.unique) _attack.unique = this.unique
        if (!_attack.severity) _attack.severity = this.severity
        return _attack
    }

    buildAttacks(schema, attack) {
        let attacks = []
        attacks.push(this.buildAttack(schema, attack))
        return attacks
    }

    buildAttack(schema, attack) {
        let location = attack.options.location ? attack.options.location : this.location

        let _schema = JSON.parse(JSON.stringify(schema))
        if (["POST", "PUT", "DELETE", "PATCH"].includes(_schema.request.method)) {
            _schema = this.modifyPostParams(_schema, attack.options)
        } else {
            _schema = this.modifyGetParams(_schema, attack.options)
        }
        if (location.includes('Headers'))
            _schema = this.modifyHeaders(_schema, attack.options)
        return _schema
    }

    validateAttack(attack, validation, original, preattack) {
        let _return = jsonLogic.apply(validation, { "attack": attack, "original": original, "module": this, "preattack": preattack })

        if (typeof (_return) == 'boolean') {
            _return = { success: _return, proof: "" }
        }
        return _return
    }
}