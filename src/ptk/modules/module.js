/* Author: Denis Podgurskii */
import { ptk_utils } from "../background/utils.js"
import { jsonLogic } from '../background/lib/json-logic-js.js'

export class ptk_module {
    constructor(module) {
        Object.assign(this, module)
        this.nonAttackParams = ['csrf', '_csrf']

        jsonLogic.add_operation("regex", this.op_regex)
        jsonLogic.add_operation("proof", this.op_proof)

    }

    op_regex(obj, pattern) {
        let success = false
        pattern = new RegExp(pattern, "gmi")
        if (Array.isArray(obj)) {
            Object.entries(obj).forEach(([_key, _value]) => {
                if (pattern.test(JSON.stringify(_value))) {
                    success = true
                }
            })
        } else {
            success = pattern.test(obj)
        }
        return success
    }

    op_proof(obj, pattern) {
        let proof = ""
        pattern = new RegExp(pattern, "gmi")
        if (Array.isArray(obj)) {
            Object.entries(obj).forEach(([_key, _value]) => {
                if (pattern.test(JSON.stringify(_value))) {
                    proof = JSON.stringify(_value).match(pattern)[0]
                }
            })
        } else {
            if (pattern.test(obj))
                proof = obj.match(pattern)[0]
        }
        return proof
    }

    modifyProps(schema, options) {
        for (let i = 0; i < options.props.length; i++) {
            ptk_utils.jsonSetValueByPath(schema, options.props[i].name, options.props[i].value, true)
        }
        return schema
    }

    modifyParam(name, param, options) {
        if (this.nonAttackParams.includes(name)) return param
        if (options.regex) {
            let r = new RegExp(options.regex)
            param = param.replace(r, options.value)
        } else if (options.operation == 'add') {
            param = (options.position == 'after') ? param + options.value : options.value + param
        } else if (options.operation == 'replace') {
            param = options.value
        }

        return param
    }

    modifyPostParams(schema, options) {
        let params = schema.request.body?.params
        if (params) {
            for (let j = 0; j < options.params.length; j++) {
                if (options.params[j].name) {
                    let ind = params.findIndex(obj => { return obj.name.toLowerCase() == options.params[j].name.toLowerCase() })
                    if (ind < 0) {
                        params.push({
                            "name": options.params[j].name,
                            "value": options.params[j].value
                        })
                    } else {
                        params[ind].value = this.modifyParam(params[ind].name, params[ind].value, options.params[j])
                    }
                } else {
                    for (let i in params) {
                        params[i].value = this.modifyParam(params[i].name, params[i].value, options.params[j])
                    }
                }
            }
        }
        return schema
    }

    modifyGetParams(schema, options) {
        let url = new URL(schema.request.target)
        let params = schema.request.queryParams
        if (params) {
            for (let j = 0; j < options.params.length; j++) {
                if (options.params[j].name) {
                    let ind = params.findIndex(obj => { return obj.name.toLowerCase() == options.params[j].name.toLowerCase() })
                    let val = options.params[j].value
                    if (ind < 0) {
                        params.push({
                            "name": options.params[j].name,
                            "value": options.params[j].value
                        })

                    } else {
                        params[ind].value = this.modifyParam(params[ind].name, params[ind].value, options.params[j])
                        val = params[ind].value
                    }
                    url.searchParams.set(options.params[j].name, val)
                } else {
                    for (let i in params) {
                        params[i].value = this.modifyParam(params[i].name, params[i].value, options.params[j])
                        url.searchParams.set(params[i].name, params[i].value)
                    }
                }
            }
        }
        schema.request.target = url.toString()
        return schema
    }

    modifyHeaders(schema, options) {
        let params = schema.request.headers
        for (let j = 0; j < options.headers.length; j++) {
            if (options.headers[j].name) {
                let ind = params.findIndex(obj => { return obj.name.toLowerCase() == options.headers[j].name.toLowerCase() })
                if (ind < 0) {
                    params.push({
                        "name": options.headers[j].name,
                        "value": options.headers[j].value
                    })
                } else {
                    params[ind].value = this.modifyParam(params[ind].name, params[ind].value, options.headers[j])
                }
            } else {
                for (let i in params) {
                    params[i].value = this.modifyParam(params[i].name, params[i].value, options.headers[j])
                }
            }
        }
        return schema
    }



    prepareAttack(attack) {
        let rnd = ptk_utils.attackParamId()

        if (attack.options?.random)
            attack.options.random = rnd

        for (let j = 0; j < attack.options?.props?.length; j++) {
            attack.options.props[j].value = attack.options.props[j].value.replace('%%random%%', rnd)
        }
        for (let j = 0; j < attack.options?.params?.length; j++) {
            attack.options.params[j].value = attack.options.params[j].value.replace('%%random%%', rnd)
        }
        for (let j = 0; j < attack.options?.headers?.length; j++) {
            attack.options.headers[j].value = attack.options.headers[j].value.replace('%%random%%', rnd)
        }
        if (attack?.regex) {
            attack.regex = JSON.parse(JSON.stringify(attack.regex).replace('%%random%%', rnd))
        }

        if (!attack.unique) attack.unique = this.unique
        if (!attack.severity) attack.severity = this.severity
        return attack
    }

    buildAttacks(schema, attack) {
        let attacks = []
        attacks.push(this.buildAttack(schema, attack))
        return attacks
    }

    buildAttack(schema, attack) {
        let _schema = JSON.parse(JSON.stringify(schema))

        // modify properties, eg method or scheme
        if (attack.options.props) {
            _schema = this.modifyProps(_schema, attack.options)
        }
        // modify params - POST or GET
        if (attack.options.params) {
            if (["POST", "PUT", "DELETE", "PATCH"].includes(_schema.request.method)) {
                _schema = this.modifyPostParams(_schema, attack.options)
            } else {
                _schema = this.modifyGetParams(_schema, attack.options)
            }
        }
        // modify headers
        if (attack.options.headers) {
            _schema = this.modifyHeaders(_schema, attack.options)
        }
        return _schema
    }

    validateAttackConditions(conditions, original) {
        return jsonLogic.apply(conditions, { "original": original, "module": this })
    }

    validateAttack(attack, original) {
        let success = jsonLogic.apply(attack.validation.rule, { "attack": attack, "original": original, "module": this })
        let proof = ""
        if (attack.validation.proof && success) {
            proof = jsonLogic.apply(attack.validation.proof, { "attack": attack, "original": original, "module": this })
        }
        return { "success": success, "proof": proof }
    }
}