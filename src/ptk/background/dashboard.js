/* Author: Denis Podgurskii */
import { Wappalyzer } from "../packages/wappalyzer/wappalyzer.js"
import { HttpHeadersCheck } from "../modules/passive/headers.js"


export class ptk_dashboard {
    constructor() {

        this.Wappalyzer = Wappalyzer

        fetch(chrome.runtime.getURL('ptk/packages/wappalyzer/technologies.json'))
            .then(response => response.json())
            .then(data => {
                this.technologies = data.technologies
                this.categories = data.categories
            })

        fetch(chrome.runtime.getURL('ptk/background/waf.json'))
            .then(response => response.json())
            .then(data => {
                this.wafTechnologies = data.technologies
                this.wafCategories = data.categories
            })

        this.addMessageListiners()
    }

    async initCookies(domains) {

        let cookies = {}
        for (let i = 0; i < domains.length; i++) {
            await browser.cookies.getAll({ 'domain': domains[i] }).then(function (cookie) { cookies[domains[i]] = cookie })
        }

        browser.runtime.sendMessage({
            channel: "ptk_background2popup_dashboard",
            type: "init_complete",
            data: Object.assign({}, { cookies: cookies })
        })

        return Promise.resolve()
    }

    async analyzeTab(message) {
        this.Wappalyzer.setTechnologies(this.technologies)
        this.Wappalyzer.setCategories(this.categories)


        let detections = await this.Wappalyzer.analyze({
            headers: this.tab.responseHeaders,
            meta: message.info.meta,
            scripts: message.info.scripts,
            html: message.info.html,
            js: message.info.js
        }).then((detections) => {
            return this.Wappalyzer.resolve(detections)
        })

        let technologies = Array.prototype.concat.apply(
            [],
            message.info.dom.map(({ name, selector, text, property, attribute, value }) => {
                const technology = this.Wappalyzer.technologies.find(({ name: _name }) => name === _name)

                if (text) {
                    return this.Wappalyzer.analyzeManyToMany(technology, 'dom.text', { [selector]: [text], })
                }

                if (property) {
                    return this.Wappalyzer.analyzeManyToMany(technology, `dom.properties.${property}`, { [selector]: [value], })
                }

                if (attribute) {
                    return this.Wappalyzer.analyzeManyToMany(technology, `dom.attributes.${attribute}`, { [selector]: [value], })
                }

                return []
            })
        )

        technologies = Array.prototype.concat.apply(
            technologies,
            message.info.js.map(({ name, chain, value }) => {
                const technology = this.Wappalyzer.technologies.find(({ name: _name }) => name === _name)

                if (name) {
                    return this.Wappalyzer.analyzeManyToMany(technology, 'js', { [chain]: [value], })
                }

                return []
            })
        )


        technologies = technologies.map(item => { return { name: item.technology.name, version: item.version ? item.version : "" } })
        const result = [];
        const map = new Map();
        for (const item of technologies) {
            if (!map.has(item.name)) {
                map.set(item.name, true);    // set any value to Map
                result.push({
                    name: item.name,
                    version: item.version
                });
            } else if(map.has(item.name) && result.findIndex(i => i.name == item.name) > -1){
                result[result.findIndex(i => i.name == item.name)].version = item.version
            }
        }
        technologies = result

        Object.keys(detections).forEach(i => {
            let item = technologies.find(item => item.name == detections[i].name)
            if (!item) {
                technologies.push({ name: detections[i].name, version: detections[i].version })
            } else if (!item.version) {
                item.version = detections[i].version
            }
        })
        //technologies = [...new Set(technologies)];
        //technologies = Array.prototype.concat.apply(technologies, detections)

        //WAF
        this.Wappalyzer.setTechnologies(this.wafTechnologies)
        this.Wappalyzer.setCategories(this.wafCategories)

        let wafDetections = await this.Wappalyzer.analyze({
            headers: this.tab.responseHeaders,
            meta: message.info.meta,
            scripts: message.info.scripts,
            html: message.info.html
        }).then((detections) => {
            return this.Wappalyzer.resolve(detections)
        })
        //let wafTechnologies = this.Wappalyzer.resolve(wafDetections)


        browser.runtime.sendMessage({
            channel: "ptk_background2popup_dashboard",
            type: "analyze_complete",
            data: Object.assign({}, { technologies: technologies, waf: wafDetections })
        })

        return Promise.resolve()
    }



    /* Listeners */

    addMessageListiners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {

        if (message.channel == "ptk_popup2background_dashboard") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve()
        }
    }

    async msg_init(message) {

        this.activeTab = window.ptk_app.proxy.activeTab
        // let current = await browser.tabs.get(this.activeTab.tabId)
        // this.activeTab.url = current.url

        this.Wappalyzer.setTechnologies(this.technologies)
        this.Wappalyzer.setCategories(this.categories)

        this.wappalyzerDomRules = this.Wappalyzer.technologies
            .filter(({ dom }) => dom)
            .map(({ name, dom }) => ({ name, dom }))
            .filter(item => item.dom != "")

        this.wappalyzerJsRules = this.Wappalyzer.technologies
            .filter(({ js }) => js)
            .map(({ name, js }) => ({ name, js }))
            .filter(item => item.js != "")

        if (window.ptk_app.proxy.isTabsCapturingActive && this.activeTab?.tabId) {

            // setTimeout(() => {

            browser.tabs.sendMessage(this.activeTab.tabId, {
                channel: "ptk_background2content",
                type: "init",
                dom: this.wappalyzerDomRules,
                js: this.wappalyzerJsRules
            }).catch(() => { })
            // }, 150)

            let tab = window.ptk_app.proxy.getTab(this.activeTab.tabId)
            let self = this
            if (tab) {
                return tab?.analyze().then(function (result) {
                    self['tab'] = result
                    let findings = HttpHeadersCheck.checkSecurityHeaders(tab)
                    self.initCookies(result.domains)

                    return Promise.resolve(Object.assign({}, result, window.ptk_app.proxy.activeTab, { proxyOn: window.ptk_app.proxy.isTabsCapturingActive, findings: findings }))
                })
            }
        }
        return Promise.resolve(Object.assign({}, window.ptk_app.proxy.activeTab, { proxyOn: window.ptk_app.proxy.isTabsCapturingActive }))
    }

    async msg_cve(message) {
        this.activeTab = window.ptk_app.proxy.activeTab
        let tab = window.ptk_app.proxy.getTab(this.activeTab.tabId)
        let self = this
        if (tab) {
            return tab?.analyze().then(function (result) {
                self['tab'] = result
                return Promise.resolve(Object.assign({}, result, window.ptk_app.proxy.activeTab, { proxyOn: window.ptk_app.proxy.isTabsCapturingActive }))
            })
        }
    }

    msg_analyze(message, tab) {
        if (!this.tab) return
        this.analyzeTab(message)
        return Promise.resolve()
    }

    /* End Listeners */
}