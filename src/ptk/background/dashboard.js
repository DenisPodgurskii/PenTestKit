/* Author: Denis Podgurskii */
import { Wappalyzer } from "../packages/wappalyzer/wappalyzer.js"
import { Wappalyzer as WafWappalyzer } from "../packages/wappalyzer/wappalyzer.js"
import { HttpHeadersCheck } from "../modules/passive/headers.js"


export class ptk_dashboard {
    constructor() {

        fetch(chrome.runtime.getURL('ptk/packages/wappalyzer/technologies.json'))
            .then(response => response.json())
            .then(data => {
                this.technologies = data.technologies
                this.categories = data.categories
            })

        fetch(chrome.runtime.getURL('ptk/background/waf.json'))
            .then(response => response.json())
            .then(data => {
                this.wafTechnologies = data.technologies
                this.wafCategories = data.categories
            })

        this.addMessageListiners()
    }

    async initCookies(domains) {

        let cookies = {}
        for (let i = 0; i < domains.length; i++) {
            await browser.cookies.getAll({ 'domain': domains[i] }).then(function (cookie) { cookies[domains[i]] = cookie })
        }
        this.tab.cookies = cookies
        browser.runtime.sendMessage({
            channel: "ptk_background2popup_dashboard",
            type: "init_complete",
            data: Object.assign({}, { cookies: cookies })
        })

        return Promise.resolve()
    }

    async analyzeTab(message) {

        let detections =  Wappalyzer.analyze({
            headers: this.tab.responseHeaders,
            meta: message.info.meta,
            scripts: message.info.scripts,
            html: message.info.html,
            js: message.info.js
        })
        // .then((detections) => {
        //     return Wappalyzer.resolve(detections)
        // }).catch(e => [e])


        let technologies = Array.prototype.concat.apply(
            [],
            message.info.dom.map(({ name, selector, text, property, attribute, value }) => {
                const technology = Wappalyzer.technologies.find(({ name: _name }) => name === _name)

                if (text) {
                    return Wappalyzer.analyzeManyToMany(technology, 'dom.text', { [selector]: [text], })
                }

                if (property) {
                    return Wappalyzer.analyzeManyToMany(technology, `dom.properties.${property}`, { [selector]: [value], })
                }

                if (attribute) {
                    return Wappalyzer.analyzeManyToMany(technology, `dom.attributes.${attribute}`, { [selector]: [value], })
                }

                return []
            })
        )

        technologies = Array.prototype.concat.apply(
            technologies,
            message.info.js.map(({ name, chain, value }) => {
                const technology = Wappalyzer.technologies.find(({ name: _name }) => name === _name)

                if (name) {
                    return Wappalyzer.analyzeManyToMany(technology, 'js', { [chain]: [value], })
                }

                return []
            })
        )


        technologies = technologies.map(item => { return { name: item.technology.name, version: item.version ? item.version : "" } })
        const result = [];
        const map = new Map();
        for (const item of technologies) {
            if (!map.has(item.name)) {
                map.set(item.name, true);    // set any value to Map
                result.push({
                    name: item.name,
                    version: item.version
                });
            } else if (map.has(item.name) && result.findIndex(i => i.name == item.name) > -1) {
                result[result.findIndex(i => i.name == item.name)].version = item.version
            }
        }
        technologies = result

        Object.keys(detections).forEach(i => {
            let item = technologies.find(item => item.name == detections[i].technology.name)
            if (!item) {
                technologies.push({ name: detections[i].technology.name, version: detections[i].version })
            } else if (!item.version) {
                item.version = detections[i].version
            }
        })


        //WAF
        let wafDetections = {}
        this.setWappalyzer(this.wafTechnologies, this.wafCategories)

        wafDetections = await Wappalyzer.analyze({
            headers: this.tab.responseHeaders,
            meta: message.info.meta,
            scripts: message.info.scripts,
            html: message.info.html
        })
        // .then((detections) => {
        //     return Wappalyzer.resolve(detections)
        // })


        this.tab.technologies = technologies
        this.tab.waf = Wappalyzer.resolve(wafDetections)
        this.tab.storage = message.info.auth

        let self = this
        try {
            self = JSON.parse(JSON.stringify(this))//FF fix
        } catch (e) {

        }
        browser.runtime.sendMessage({
            channel: "ptk_background2popup_dashboard",
            type: "analyze_complete",
            data: Object.assign({}, self)
        })

        return Promise.resolve()
    }

    setWappalyzer(technologies, categories) {
        Wappalyzer.technologies = []
        Wappalyzer.categories = []
        Wappalyzer.requires = []
        Wappalyzer.categoryRequires = []
        Wappalyzer.setTechnologies(technologies)
        Wappalyzer.setCategories(categories)
    }



    /* Listeners */

    addMessageListiners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {

        if (message.channel == "ptk_popup2background_dashboard") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve()
        }
    }

    async msg_get(message) {
        return Promise.resolve(Object.assign({},
            this,
            window.ptk_app.proxy.activeTab,
            {
                proxyOn: window.ptk_app.proxy.isTabsCapturingActive
            }))
    }

    async msg_init(message) {

        //this.Wappalyzer = Wappalyzer

        this.activeTab = window.ptk_app.proxy.activeTab

        this.privacy = window.ptk_app.settings.privacy

        this.setWappalyzer(this.technologies, this.categories)

        this.wappalyzerDomRules = Wappalyzer.technologies
            .filter(({ dom }) => dom)
            .map(({ name, dom }) => ({ name, dom }))
            .filter(item => item.dom != "")

        this.wappalyzerJsRules = Wappalyzer.technologies
            .filter(({ js }) => js)
            .map(({ name, js }) => ({ name, js }))
            .filter(item => item.js != "")

        if (window.ptk_app.proxy.isTabsCapturingActive && this.activeTab?.tabId) {

            browser.tabs.sendMessage(this.activeTab.tabId, {
                channel: "ptk_background2content",
                type: "init",
                dom: this.wappalyzerDomRules,
                js: this.wappalyzerJsRules
            }).catch(() => { })

            let tab = window.ptk_app.proxy.getTab(this.activeTab.tabId)
            let self = this
            if (tab) {
                return tab?.analyze().then(function (result) {
                    self['tab'] = result
                    self.tab.findings = HttpHeadersCheck.checkSecurityHeaders(tab)
                    self.initCookies(result.domains)

                    return Promise.resolve(Object.assign({}, self, window.ptk_app.proxy.activeTab, { proxyOn: window.ptk_app.proxy.isTabsCapturingActive, findings: self.tab.findings }))
                })
            }
        }
        return Promise.resolve(Object.assign({}, window.ptk_app.proxy.activeTab, { proxyOn: window.ptk_app.proxy.isTabsCapturingActive, privacy: this.privacy }))
    }

    msg_analyze(message, tab) {
        if (!this.tab) return
        this.analyzeTab(message)
        return Promise.resolve(Object.assign({}, this))
    }

    /* End Listeners */
}