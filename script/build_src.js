import { createRequire } from 'module'
const require = createRequire(import.meta.url)
const fs = require('fs-extra')
const request = require('request')


//http-z
if (!fs.existsSync('src/ptk/packages/http-z')) {
    fs.mkdirSync('src/ptk/packages/http-z', { recursive: true });
}
fs.copyFile('./misc/dist/http-z.es6.js', 'src/ptk/packages/http-z/http-z.es6.js', (err) => {
    if (err) throw err;
});


//browser-polyfill
if (!fs.existsSync('src/ptk/packages/browser-polyfill')) {
    fs.mkdirSync('src/ptk/packages/browser-polyfill', { recursive: true });
}
fs.copyFile('node_modules/webextension-polyfill/dist/browser-polyfill.min.js', 'src/ptk/packages/browser-polyfill/browser-polyfill.min.js', (err) => {
    if (err) throw err;
});
fs.copyFile('./node_modules/webextension-polyfill/dist/browser-polyfill.min.js.map', 'src/ptk/packages/browser-polyfill/browser-polyfill.min.js.map', (err) => {
    if (err) throw err;
});


//wappalyzer
if (!fs.existsSync('src/ptk/packages/wappalyzer')) {
    fs.mkdirSync('src/ptk/packages/wappalyzer', { recursive: true });
}
fs.copyFile('node_modules/wappalyzer/wappalyzer.js', 'src/ptk/packages/wappalyzer/wappalyzer.js', (err) => {
    if (err) throw err;
});
fs.appendFile('src/ptk/packages/wappalyzer/wappalyzer.js', 'export { Wappalyzer }', function (err) {
    if (err) throw err;
});


//jquery
if (!fs.existsSync('src/ptk/packages/jquery')) {
    fs.mkdirSync('src/ptk/packages/jquery',{ recursive: true });
}
fs.copyFile('./node_modules/jquery/dist/jquery.min.js', 'src/ptk/packages/jquery/jquery.min.js', (err) => {
    if (err) throw err;
});
fs.copyFile('./node_modules/jquery/dist/jquery.min.map', 'src/ptk/packages/jquery/jquery.min.map', (err) => {
    if (err) throw err;
});
fs.copyFile('./node_modules/datatables.net/js/jquery.dataTables.min.js', 'src/ptk/packages/jquery/jquery.dataTables.min.js', (err) => {
    if (err) throw err;
});


//semantic-ui / fomantic-ui
if (!fs.existsSync('src/ptk/packages/semantic-ui')) {
    fs.mkdirSync('src/ptk/packages/semantic-ui',{ recursive: true });
}
fs.copyFile('./node_modules/fomantic-ui/dist/semantic.min.js', 'src/ptk/packages/semantic-ui/semantic.min.js', (err) => {
    if (err) throw err;
});
fs.copyFile('./node_modules/fomantic-ui/dist/semantic.min.css', 'src/ptk/packages/semantic-ui/semantic.min.css', (err) => {
    if (err) throw err;
});

if (!fs.existsSync('src/ptk/packages/semantic-ui/themes/default')) {
    fs.mkdirSync('src/ptk/packages/semantic-ui/themes/default', { recursive: true });
}
fs.copySync('./node_modules/fomantic-ui/dist/themes/default', 'src/ptk/packages/semantic-ui/themes/default', { recursive: true })


//codemirror
if (!fs.existsSync('src/ptk/packages/codemirror')) {
    fs.mkdirSync('src/ptk/packages/codemirror', { recursive: true });
}
fs.copyFile('./node_modules/codemirror-minified/lib/codemirror.js', 'src/ptk/packages/codemirror/codemirror.js', (err) => {
    if (err) throw err;
});
fs.copyFile('./node_modules/codemirror-minified/lib/codemirror.css', 'src/ptk/packages/codemirror/codemirror.css', (err) => {
    if (err) throw err;
});
fs.copyFile('./node_modules/codemirror-minified/lib/codemirror.css', 'src/ptk/packages/codemirror/codemirror.css', (err) => {
    if (err) throw err;
});
if (!fs.existsSync('src/ptk/packages/codemirror/addon/fold/')) {
    fs.mkdirSync('src/ptk/packages/codemirror/addon/fold/', { recursive: true });
    fs.mkdirSync('src/ptk/packages/codemirror/mode/xml/', { recursive: true });
    fs.mkdirSync('src/ptk/packages/codemirror/mode/javascript/', { recursive: true });
}
fs.copySync('./node_modules/codemirror-minified/addon/fold', 'src/ptk/packages/codemirror/addon/fold', { recursive: true })
fs.copySync('./node_modules/codemirror-minified/mode/xml', 'src/ptk/packages/codemirror/mode/xml', { recursive: true })
fs.copySync('./node_modules/codemirror-minified/mode/javascript', 'src/ptk/packages/codemirror/mode/javascript', { recursive: true })


//mermaid
if (!fs.existsSync('src/ptk/packages/mermaid')) {
    fs.mkdirSync('src/ptk/packages/mermaid', { recursive: true });
}
fs.copyFile('./node_modules/mermaid/dist/mermaid.min.js', 'src/ptk/packages/mermaid/mermaid.min.js', (err) => {
    if (err) throw err;
});


//swagger-editor
if (!fs.existsSync('src/ptk/packages/swagger-editor')) {
    fs.mkdirSync('src/ptk/packages/swagger-editor', { recursive: true });
}
fs.copyFile('./node_modules/swagger-editor/dist/swagger-editor.css', 'src/ptk/packages/swagger-editor/swagger-editor.css', (err) => {
    if (err) throw err;
});
fs.copyFile('./node_modules/swagger-editor/dist/swagger-editor-bundle.js', 'src/ptk/packages/swagger-editor/swagger-editor-bundle.js', (err) => {
    if (err) throw err;
});
request('https://raw.githubusercontent.com/swagger-api/swagger-editor/master/dist/swagger-editor-standalone-preset.js').pipe(fs.createWriteStream('src/ptk/packages/swagger-editor/swagger-editor-standalone-preset.js'))



//crypto-es
if (!fs.existsSync('src/ptk/packages/crypto-es')) {
    fs.mkdirSync('src/ptk/packages/crypto-es', { recursive: true });
}
fs.copySync('./node_modules/crypto-es/lib', 'src/ptk/packages/crypto-es', { recursive: true })


//retire
if (!fs.existsSync('src/ptk/packages/retire')) {
    fs.mkdirSync('src/ptk/packages/retire', { recursive: true });
}
fs.removeSync('./misc/tmp/')

const clone = require('git-clone/promise')
await clone("git@github.com:RetireJS/retire.js.git", "./misc/tmp/retire");
fs.copyFile('misc/tmp/retire/node/lib/retire.js', 'src/ptk/packages/retire/retire.js', (err) => {
    if (err) throw err;
});
fs.copyFile('misc/tmp/retire/repository/jsrepository.json', 'src/ptk/packages/retire/jsrepository.json', (err) => {
    if (err) throw err;
});
fs.appendFile('src/ptk/packages/retire/retire.js', 'export { exports as default }', function (err) {
    if (err) throw err;
});
fs.removeSync('./misc/tmp/')
